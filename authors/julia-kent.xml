<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>NCAR XDev (Posts by Julia Kent)</title><link>https://ncar.github.io/xdev/</link><description></description><atom:link href="https://ncar.github.io/xdev/authors/julia-kent.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:xdev@ucar.edu"&gt;The NCAR Experimental Development Team&lt;/a&gt; </copyright><lastBuildDate>Fri, 09 Aug 2019 17:33:42 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Time</title><link>https://ncar.github.io/xdev/posts/time/</link><dc:creator>Julia Kent</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="The-Significance-of-Time"&gt;The Significance of Time&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Significance-of-Time"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Time is relative, as my coworker Anderson likes to remind me every time manipulating this coordinate proves to be relatively difficult.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;This post is to be the first in a series of my struggles coming from an atmospheric science background and transitioning into software. My hope is that if I detail pain points and headaches I encounter along my journey- you won’t have to.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="The-Task"&gt;The Task&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Task"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Lately, I’ve been working on a project that compares modeled and measured data, which is pretty standard. The measured data is on a Gregorian calendar (meaning there are leap years), and the modeled data is on a 365-day no-leap calendar. This is a pretty standard occurrence, so there are tools available in pandas and xarray to help. But finding the correct steps across the many platforms that host documentation can be difficult -- so let me add one more platform &lt;em&gt;this blog&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First tip: You can find out the calendar your data is on using &lt;code&gt;xarray.dataset.time.encoding&lt;/code&gt;.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="The-Temptation"&gt;The Temptation&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Temptation"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;At several moments I seriously considered writing my own functions to deal with date time. When I talked to some of my friends (who are scientists about it), they confessed to me that they had each written their own function for dealing with this. This is a problem. One of the tenants of the Pangeo community is making it so scientists aren’t all repeating the same work when encountering similar problems. I couldn’t write my own function for time, it was my job to demonstrate how to use the tools already approved by the Pangeo community. But it felt like all of the tools worked differently in different scenarios. I had to navigate the documentation to figure out the when and why of time.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="The-Tribulation"&gt;The Tribulation&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Tribulation"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Essentially my data is in two distinct conventional ways of formatting time: datetime64 and cftime. Both of these methods have different benefits.&lt;/p&gt;
&lt;p&gt;All of the data is initally in float32 or float64, which Xarray can automatically decode for me based on the time units and bounds supplied. If you did not want this to happen, then in &lt;code&gt;xarray.open_dataset()&lt;/code&gt; specify the keyword argument &lt;code&gt;decode_cf=False&lt;/code&gt;. &lt;strong&gt;In this case your time will be a series of float values that cannot be understood without your units&lt;/strong&gt;, in this example (days since 1900-01-01):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray 'time' (time: 12784)&amp;gt;
array([28854.75, 28855.75, 28856.75, ..., 41635.75, 41636.75, 41637.75],
      dtype=float32)
Coordinates:
  * time     (time) float32 28854.75 28855.75 28856.75 ... 41636.75 41637.75
Attributes:
    axis:           T
    standard_name:  time
    long_name:      time
    calendar:       gregorian
    units:          days since 1900-01-01 00:00:00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;I have never specified this option and think decoding data according to CF conventions is typically preferred.&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;For the measured data, on a Gregorian calendar, time is converted to &lt;strong&gt;datetime64&lt;/strong&gt; format which takes the following form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray 'time' (time: 12784)&amp;gt;
array(['1979-01-01T18:00:00.000000000', '1979-01-02T18:00:00.000000000',
       '1979-01-03T18:00:00.000000000', ..., '2013-12-29T18:00:00.000000000',
       '2013-12-30T18:00:00.000000000', '2013-12-31T18:00:00.000000000'],
      dtype='datetime64[ns]')
Coordinates:
  * time     (time) datetime64[ns] 1979-01-01T18:00:00 ... 2013-12-31T18:00:00&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;strong&gt;datetime64 is not yet supported for a no-leap calendar&lt;/strong&gt;, and since the modeled data is on a no-leap calendar- time is returned in &lt;strong&gt;cftime.DatetimeNoLeap&lt;/strong&gt;. This looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xarray.DataArray 'time' (time: 20440)&amp;gt;
array([cftime.DatetimeNoLeap(1950, 1, 1, 12, 0, 0, 0, 4, 1),
       cftime.DatetimeNoLeap(1950, 1, 2, 12, 0, 0, 0, 5, 2),
       cftime.DatetimeNoLeap(1950, 1, 3, 12, 0, 0, 0, 6, 3), ...,
       cftime.DatetimeNoLeap(2005, 12, 29, 12, 0, 0, 0, 1, 363),
       cftime.DatetimeNoLeap(2005, 12, 30, 12, 0, 0, 0, 2, 364),
       cftime.DatetimeNoLeap(2005, 12, 31, 12, 0, 0, 0, 3, 365)], dtype=object)
Coordinates:
  * time     (time) object 1950-01-01 12:00:00 ... 2005-12-31 12:00:00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So I need my data to be in the same format, but which one to pick?&lt;/p&gt;
&lt;h4 id="The-Case-for-datetime64"&gt;The Case for datetime64&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Case-for-datetime64"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Sometimes I want datetime. At one point I want to split my modeled dataset into two groups: an early piece that matches the time bounds from the measured data, and a future piece that includes all of the model yet to occur and to be bias-corrected. This is done with the &lt;code&gt;xarray.dataset.sel(time = slice(a, b))&lt;/code&gt; where a and b are the first and last time point from the measured dataset as yyy-mm-dd which is &lt;strong&gt;in datetime64 formatting!&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="The-Case-for-cftime.DatetimeNoLeap"&gt;The Case for cftime.DatetimeNoLeap&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-Case-for-cftime.DatetimeNoLeap"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Converting a non-leap cftime variable to datetime64 leads to &lt;em&gt;subtle errors&lt;/em&gt;, which are avoided when I use cftime formatting.&lt;/p&gt;
&lt;p&gt;Some of these errors occur in the &lt;code&gt;xarray.dataset.groupby('time.dayofyear')&lt;/code&gt; functionality which I use retrieve average values for each day of the year, across all years in the dataset. If I am in datetime64 formatting, but with February 29th missing, this function spans 366 days for every year, instead of 365, and this error grows with every additional year of data (suddenly March 1st is averaged with March 2nd from the next year, for example). &lt;strong&gt;So I need my time coordinate to be in cftime.DatetimeNoLeap formatting.&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="The-best-of-both-worlds"&gt;The best of both worlds&lt;a class="anchor-link" href="https://ncar.github.io/xdev/posts/time/#The-best-of-both-worlds"&gt;¶&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;The usual method for converting between cftime and datetime64 is not supported for the non-standard 365 day no-leap calendar. The usual method being &lt;code&gt;pandas.to_datetime().&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;One workaround is to use &lt;code&gt;xarray.dataset.indexes[].to_datetimeindex&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;datetimeindex = da.indexes['time'].to_datetimeindex()
da['time']= ('time', datetimeindex)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which always returns this warning (remember the subtle errors I mentioned):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RuntimeWarning: Converting a CFTimeIndex with dates from a non-standard calendar, 'noleap', to a pandas.DatetimeIndex, which uses dates from the standard calendar.  This may lead to subtle errors in operations that depend on the length of time between dates.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if I want to be able to use both cftime.DatetimeNoLeap and datetime64, I had to write my own function to do this conversion:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cfnoleap_to_datetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;da&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;datetimeindex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;da&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;indexes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'time'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_datetimeindex&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;ds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;da&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_dataset&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'time_dt'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'time'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;datetimeindex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;swap_dims&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s1"&gt;'time'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'time_dt'&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;da&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time_dt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ds&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to maintain the information contained in cftime I need to upgrade my dataarray to a dataset, then add a new dimension for the datetime64 formatting of the time coordinate. Then I am able to simply use &lt;code&gt;xarray.dataset.swap_dims&lt;/code&gt; to pick which formatting I want depending on the functionality I am using.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;I guess that wasn't that hard, but I couldn't find an example of this workflow anywhere. I hope sharing it here helps anyone with similar issues!&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><guid>https://ncar.github.io/xdev/posts/time/</guid><pubDate>Thu, 08 Aug 2019 19:45:45 GMT</pubDate></item></channel></rss>